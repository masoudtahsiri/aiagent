"""
Google Calendar Watch API - Webhook Handlers
Handles real-time push notifications from Google Calendar
"""

from fastapi import APIRouter, Request, HTTPException, Header, BackgroundTasks
from datetime import datetime, timedelta
from typing import Optional
import httpx
import uuid
import logging

from backend.database.supabase_client import get_db

router = APIRouter(prefix="/api/calendar/webhooks", tags=["Calendar Webhooks"])
logger = logging.getLogger(__name__)


# =============================================================================
# WEBHOOK RECEIVER - Called by Google when calendar changes
# =============================================================================

@router.post("/google-push")
async def receive_google_push_notification(
    request: Request,
    background_tasks: BackgroundTasks,
    x_goog_channel_id: Optional[str] = Header(None),
    x_goog_resource_id: Optional[str] = Header(None),
    x_goog_resource_state: Optional[str] = Header(None),
    x_goog_channel_token: Optional[str] = Header(None),  # Contains staff_id
    x_goog_message_number: Optional[str] = Header(None),
):
    """
    Receive push notifications from Google Calendar.
    
    Google sends headers only (no body):
    - X-Goog-Channel-ID: Our channel UUID
    - X-Goog-Resource-ID: Google's resource identifier  
    - X-Goog-Resource-State: 'sync' (initial) or 'exists' (changes)
    - X-Goog-Channel-Token: Our custom token (staff_id)
    - X-Goog-Message-Number: Sequence number
    """
    logger.info(f"[Google Push] channel={x_goog_channel_id}, state={x_goog_resource_state}, token={x_goog_channel_token}")
    
    # Acknowledge sync messages immediately (sent when watch is first created)
    if x_goog_resource_state == "sync":
        logger.info("[Google Push] Sync acknowledgment received")
        return {"status": "sync_acknowledged"}
    
    # Validate we have the required headers
    if not x_goog_channel_id:
        logger.warning("[Google Push] Missing channel ID")
        return {"status": "ignored", "reason": "no_channel_id"}
    
    db = get_db()
    
    # Find the channel in our database
    channel_result = db.table("calendar_webhook_channels").select(
        "*, calendar_connections(staff_id, calendar_id)"
    ).eq("channel_id", x_goog_channel_id).execute()
    
    if not channel_result.data:
        logger.warning(f"[Google Push] Unknown channel: {x_goog_channel_id}")
        return {"status": "unknown_channel"}
    
    channel = channel_result.data[0]
    staff_id = x_goog_channel_token or channel.get("staff_id")
    
    if not staff_id:
        logger.error("[Google Push] Could not determine staff_id")
        return {"status": "error", "reason": "no_staff_id"}
    
    # Return response indicating sync is needed
    # n8n will poll this or we trigger n8n webhook
    return {
        "status": "notification_received",
        "staff_id": staff_id,
        "channel_id": x_goog_channel_id,
        "resource_state": x_goog_resource_state,
        "needs_sync": True
    }


# =============================================================================
# CHANNEL MANAGEMENT - Called by n8n
# =============================================================================

@router.post("/setup-watch")
async def setup_watch_for_staff(request: dict):
    """
    Register a Google Calendar watch for a staff member.
    
    Called by n8n with Google OAuth credentials.
    
    Request body:
    {
        "staff_id": "uuid",
        "calendar_id": "primary" or "email@gmail.com",
        "webhook_url": "https://your-domain.com/api/calendar/webhooks/google-push"
    }
    
    n8n handles the actual Google API call and passes us the result.
    """
    db = get_db()
    
    staff_id = request.get("staff_id")
    calendar_id = request.get("calendar_id", "primary")
    channel_id = request.get("channel_id")  # Generated by n8n
    resource_id = request.get("resource_id")  # From Google response
    expiration = request.get("expiration")  # Unix timestamp ms from Google
    
    if not all([staff_id, channel_id, resource_id, expiration]):
        raise HTTPException(status_code=400, detail="Missing required fields")
    
    # Convert expiration from milliseconds to timestamp
    expiration_dt = datetime.fromtimestamp(int(expiration) / 1000)
    
    # Get calendar connection ID
    conn_result = db.table("calendar_connections").select("id").eq(
        "staff_id", staff_id
    ).eq("provider", "google").execute()
    
    calendar_connection_id = conn_result.data[0]["id"] if conn_result.data else None
    
    # Upsert channel info (replace existing for this staff)
    existing = db.table("calendar_webhook_channels").select("id").eq(
        "staff_id", staff_id
    ).execute()
    
    channel_data = {
        "calendar_connection_id": calendar_connection_id,
        "staff_id": staff_id,
        "channel_id": channel_id,
        "resource_id": resource_id,
        "expiration": expiration_dt.isoformat(),
    }
    
    if existing.data:
        db.table("calendar_webhook_channels").update(channel_data).eq(
            "staff_id", staff_id
        ).execute()
        logger.info(f"[Watch] Updated watch for staff {staff_id}")
    else:
        db.table("calendar_webhook_channels").insert(channel_data).execute()
        logger.info(f"[Watch] Created watch for staff {staff_id}")
    
    return {
        "success": True,
        "staff_id": staff_id,
        "channel_id": channel_id,
        "expiration": expiration_dt.isoformat()
    }


@router.get("/expiring-channels")
async def get_expiring_channels(hours_ahead: int = 24):
    """
    Get channels that will expire within the specified hours.
    Called by n8n daily renewal workflow.
    """
    db = get_db()
    
    # Find channels expiring in the next N hours
    expiration_threshold = (datetime.utcnow() + timedelta(hours=hours_ahead)).isoformat()
    
    result = db.table("calendar_webhook_channels").select(
        "*, calendar_connections(staff_id, calendar_id)"
    ).lt("expiration", expiration_threshold).execute()
    
    channels = []
    for channel in (result.data or []):
        channels.append({
            "staff_id": channel["staff_id"],
            "channel_id": channel["channel_id"],
            "resource_id": channel["resource_id"],
            "expiration": channel["expiration"],
            "calendar_id": channel.get("calendar_connections", {}).get("calendar_id", "primary")
        })
    
    return {
        "expiring_count": len(channels),
        "channels": channels
    }


@router.post("/stop-watch")
async def stop_watch(request: dict):
    """
    Stop watching a calendar and remove from database.
    Called by n8n after stopping the watch with Google.
    """
    db = get_db()
    
    channel_id = request.get("channel_id")
    staff_id = request.get("staff_id")
    
    if channel_id:
        db.table("calendar_webhook_channels").delete().eq(
            "channel_id", channel_id
        ).execute()
    elif staff_id:
        db.table("calendar_webhook_channels").delete().eq(
            "staff_id", staff_id
        ).execute()
    else:
        raise HTTPException(status_code=400, detail="channel_id or staff_id required")
    
    return {"success": True}


@router.get("/active-watches")
async def get_active_watches():
    """
    Get all active watch channels.
    Useful for debugging and monitoring.
    """
    db = get_db()
    
    result = db.table("calendar_webhook_channels").select(
        "*, staff(name, email)"
    ).gt("expiration", datetime.utcnow().isoformat()).execute()
    
    return {
        "active_count": len(result.data or []),
        "watches": result.data or []
    }
